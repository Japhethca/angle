// Generated by AshTypescript
// Do not edit this file manually





export type Decimal = string;
export type UUID = string;
export type UtcDateTimeUsec = string;

// Bid Schema
export type BidResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "amount" | "bidType" | "itemId" | "userId" | "bidTime";
  id: UUID;
  amount: Decimal;
  bidType: "auto" | "proxy" | "manual";
  itemId: UUID;
  userId: UUID;
  bidTime: UtcDateTimeUsec;
  item: { __type: "Relationship"; __resource: ItemResourceSchema | null; };
  user: { __type: "Relationship"; __resource: UserResourceSchema | null; };
};



export type BidAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "amount" | "bidType" | "itemId" | "userId" | "bidTime";
  id: UUID;
  amount: Decimal;
  bidType: "auto" | "proxy" | "manual";
  itemId: UUID;
  userId: UUID;
  bidTime: UtcDateTimeUsec;
};


// Order Schema
export type OrderResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "status" | "amount" | "paymentReference" | "paidAt" | "dispatchedAt" | "completedAt" | "createdAt" | "itemId" | "buyerId" | "sellerId";
  id: UUID;
  status: "payment_pending" | "paid" | "dispatched" | "completed" | "cancelled";
  amount: Decimal;
  paymentReference: string | null;
  paidAt: UtcDateTimeUsec | null;
  dispatchedAt: UtcDateTimeUsec | null;
  completedAt: UtcDateTimeUsec | null;
  createdAt: UtcDateTimeUsec;
  itemId: UUID;
  buyerId: UUID;
  sellerId: UUID;
  item: { __type: "Relationship"; __resource: ItemResourceSchema; };
  buyer: { __type: "Relationship"; __resource: UserResourceSchema; };
  seller: { __type: "Relationship"; __resource: UserResourceSchema; };
  review: { __type: "Relationship"; __resource: ReviewResourceSchema | null; };
};



export type OrderAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "status" | "amount" | "paymentReference" | "paidAt" | "dispatchedAt" | "completedAt" | "createdAt" | "itemId" | "buyerId" | "sellerId";
  id: UUID;
  status: "payment_pending" | "paid" | "dispatched" | "completed" | "cancelled";
  amount: Decimal;
  paymentReference: string | null;
  paidAt: UtcDateTimeUsec | null;
  dispatchedAt: UtcDateTimeUsec | null;
  completedAt: UtcDateTimeUsec | null;
  createdAt: UtcDateTimeUsec;
  itemId: UUID;
  buyerId: UUID;
  sellerId: UUID;
};


// Review Schema
export type ReviewResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "rating" | "comment" | "insertedAt" | "orderId" | "reviewerId" | "sellerId";
  id: UUID;
  rating: number;
  comment: string | null;
  insertedAt: UtcDateTimeUsec;
  orderId: UUID;
  reviewerId: UUID;
  sellerId: UUID;
  order: { __type: "Relationship"; __resource: OrderResourceSchema; };
  reviewer: { __type: "Relationship"; __resource: UserResourceSchema; };
  seller: { __type: "Relationship"; __resource: UserResourceSchema; };
};



export type ReviewAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "rating" | "comment" | "insertedAt" | "orderId" | "reviewerId" | "sellerId";
  id: UUID;
  rating: number;
  comment: string | null;
  insertedAt: UtcDateTimeUsec;
  orderId: UUID;
  reviewerId: UUID;
  sellerId: UUID;
};


// Category Schema
export type CategoryResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "description" | "slug" | "formSchema" | "imageUrl" | "parentId";
  id: UUID;
  name: string;
  description: string | null;
  slug: string | null;
  formSchema: Record<string, any>;
  imageUrl: string | null;
  parentId: UUID | null;
  attributeSchema: { __type: "Relationship"; __array: true; __resource: AngleCatalogCategoryFieldResourceSchema; };
  category: { __type: "Relationship"; __resource: CategoryResourceSchema | null; };
  categories: { __type: "Relationship"; __array: true; __resource: CategoryResourceSchema; };
  items: { __type: "Relationship"; __array: true; __resource: ItemResourceSchema; };
};



export type CategoryAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "description" | "slug" | "formSchema" | "imageUrl" | "parentId";
  id: UUID;
  name: string;
  description: string | null;
  slug: string | null;
  formSchema: Record<string, any>;
  imageUrl: string | null;
  parentId: UUID | null;
  attributeSchema: { __type: "Relationship"; __array: true; __resource: AngleCatalogCategoryFieldAttributesOnlySchema; };
};


// OptionSet Schema
export type OptionSetResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "slug" | "description" | "parentId";
  id: UUID;
  name: string;
  slug: string;
  description: string | null;
  parentId: UUID | null;
  optionSetValues: { __type: "Relationship"; __array: true; __resource: OptionSetValueResourceSchema; };
  parent: { __type: "Relationship"; __resource: OptionSetResourceSchema | null; };
  children: { __type: "Relationship"; __array: true; __resource: OptionSetResourceSchema; };
};



export type OptionSetAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "slug" | "description" | "parentId";
  id: UUID;
  name: string;
  slug: string;
  description: string | null;
  parentId: UUID | null;
};


// OptionSetValue Schema
export type OptionSetValueResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "value" | "label" | "metadata" | "sortOrder" | "isActive" | "parentSetId" | "parentValue" | "optionSetId";
  id: UUID;
  value: string;
  label: string;
  metadata: Record<string, any> | null;
  sortOrder: number | null;
  isActive: boolean | null;
  parentSetId: UUID | null;
  parentValue: string | null;
  optionSetId: UUID;
  optionSet: { __type: "Relationship"; __resource: OptionSetResourceSchema; };
};



export type OptionSetValueAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "value" | "label" | "metadata" | "sortOrder" | "isActive" | "parentSetId" | "parentValue" | "optionSetId";
  id: UUID;
  value: string;
  label: string;
  metadata: Record<string, any> | null;
  sortOrder: number | null;
  isActive: boolean | null;
  parentSetId: UUID | null;
  parentValue: string | null;
  optionSetId: UUID;
};


// Item Schema
export type ItemResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "title" | "description" | "startingPrice" | "reservePrice" | "currentPrice" | "bidIncrement" | "slug" | "startTime" | "endTime" | "categoryId" | "lotNumber" | "publicationStatus" | "auctionStatus" | "condition" | "location" | "attributes" | "saleType" | "auctionFormat" | "buyNowPrice" | "viewCount" | "createdById" | "extensionCount" | "originalEndTime" | "bidCount" | "watcherCount";
  id: UUID;
  title: string;
  description: string | null;
  startingPrice: Decimal;
  reservePrice: Decimal | null;
  currentPrice: Decimal | null;
  bidIncrement: Decimal | null;
  slug: string | null;
  startTime: UtcDateTimeUsec | null;
  endTime: UtcDateTimeUsec | null;
  categoryId: UUID | null;
  lotNumber: string | null;
  publicationStatus: "draft" | "pending" | "published" | "unpublished" | "archived" | null;
  auctionStatus: "pending" | "scheduled" | "active" | "paused" | "ended" | "sold" | "cancelled" | null;
  condition: "new" | "used" | "refurbished" | null;
  location: string | null;
  attributes: Record<string, any>;
  saleType: "auction" | "buy_now" | "hybrid";
  auctionFormat: "standard" | "reserve" | "live" | "timed" | null;
  buyNowPrice: Decimal | null;
  viewCount: number | null;
  createdById: UUID | null;
  extensionCount: number | null;
  originalEndTime: UtcDateTimeUsec | null;
  bidCount: number;
  watcherCount: number;
  user: { __type: "Relationship"; __resource: UserResourceSchema | null; };
  category: { __type: "Relationship"; __resource: CategoryResourceSchema | null; };
};



export type ItemAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "title" | "description" | "startingPrice" | "reservePrice" | "currentPrice" | "bidIncrement" | "slug" | "startTime" | "endTime" | "categoryId" | "lotNumber" | "publicationStatus" | "auctionStatus" | "condition" | "location" | "attributes" | "saleType" | "auctionFormat" | "buyNowPrice" | "viewCount" | "createdById" | "extensionCount" | "originalEndTime";
  id: UUID;
  title: string;
  description: string | null;
  startingPrice: Decimal;
  reservePrice: Decimal | null;
  currentPrice: Decimal | null;
  bidIncrement: Decimal | null;
  slug: string | null;
  startTime: UtcDateTimeUsec | null;
  endTime: UtcDateTimeUsec | null;
  categoryId: UUID | null;
  lotNumber: string | null;
  publicationStatus: "draft" | "pending" | "published" | "unpublished" | "archived" | null;
  auctionStatus: "pending" | "scheduled" | "active" | "paused" | "ended" | "sold" | "cancelled" | null;
  condition: "new" | "used" | "refurbished" | null;
  location: string | null;
  attributes: Record<string, any>;
  saleType: "auction" | "buy_now" | "hybrid";
  auctionFormat: "standard" | "reserve" | "live" | "timed" | null;
  buyNowPrice: Decimal | null;
  viewCount: number | null;
  createdById: UUID | null;
  extensionCount: number | null;
  originalEndTime: UtcDateTimeUsec | null;
};


// WatchlistItem Schema
export type WatchlistItemResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "itemId";
  id: UUID;
  userId: UUID;
  itemId: UUID;
  user: { __type: "Relationship"; __resource: UserResourceSchema | null; };
  item: { __type: "Relationship"; __resource: ItemResourceSchema | null; };
};



export type WatchlistItemAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "userId" | "itemId";
  id: UUID;
  userId: UUID;
  itemId: UUID;
};


// User Schema
export type UserResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "email" | "fullName" | "phoneNumber" | "username" | "location" | "whatsappNumber" | "autoCharge" | "createdAt" | "publishedItemCount" | "reviewCount" | "avgRating";
  id: UUID;
  email: string;
  fullName: string | null;
  phoneNumber: string | null;
  username: string | null;
  location: string | null;
  whatsappNumber: string | null;
  autoCharge: boolean | null;
  createdAt: UtcDateTimeUsec;
  publishedItemCount: number;
  reviewCount: number;
  avgRating: number;
  notificationPreferences: { __type: "Relationship"; __resource: AngleAccountsNotificationPreferencesResourceSchema | null; };
  storeProfile: { __type: "Relationship"; __resource: StoreProfileResourceSchema | null; };
  items: { __type: "Relationship"; __array: true; __resource: ItemResourceSchema; };
  receivedReviews: { __type: "Relationship"; __array: true; __resource: ReviewResourceSchema; };
};



export type UserAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "email" | "fullName" | "phoneNumber" | "username" | "location" | "whatsappNumber" | "autoCharge" | "createdAt";
  id: UUID;
  email: string;
  fullName: string | null;
  phoneNumber: string | null;
  username: string | null;
  location: string | null;
  whatsappNumber: string | null;
  autoCharge: boolean | null;
  createdAt: UtcDateTimeUsec;
  notificationPreferences: { __type: "Relationship"; __resource: AngleAccountsNotificationPreferencesAttributesOnlySchema | null; };
};


// StoreProfile Schema
export type StoreProfileResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "storeName" | "contactPhone" | "whatsappLink" | "location" | "address" | "deliveryPreference" | "userId";
  id: UUID;
  storeName: string;
  contactPhone: string | null;
  whatsappLink: string | null;
  location: string | null;
  address: string | null;
  deliveryPreference: string | null;
  userId: UUID;
  user: { __type: "Relationship"; __resource: UserResourceSchema; };
};



export type StoreProfileAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "id" | "storeName" | "contactPhone" | "whatsappLink" | "location" | "address" | "deliveryPreference" | "userId";
  id: UUID;
  storeName: string;
  contactPhone: string | null;
  whatsappLink: string | null;
  location: string | null;
  address: string | null;
  deliveryPreference: string | null;
  userId: UUID;
};


// AngleCatalogCategoryField Schema
export type AngleCatalogCategoryFieldResourceSchema = {
  __type: "Resource";
  __primitiveFields: "name" | "type" | "required" | "description" | "optionSetSlug" | "options";
  name: string;
  type: string;
  required: boolean;
  description: string | null;
  optionSetSlug: string | null;
  options: Array<string> | null;
};



export type AngleCatalogCategoryFieldAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "name" | "type" | "required" | "description" | "optionSetSlug" | "options";
  name: string;
  type: string;
  required: boolean;
  description: string | null;
  optionSetSlug: string | null;
  options: Array<string> | null;
};


export type AngleCatalogCategoryFieldInputSchema = {
  name: string;
  type?: string;
  required?: boolean;
  description?: string | null;
  optionSetSlug?: string | null;
  options?: Array<string> | null;
};


// AngleAccountsNotificationPreferences Schema
export type AngleAccountsNotificationPreferencesResourceSchema = {
  __type: "Resource";
  __primitiveFields: "pushBidding" | "pushWatchlist" | "pushPayments" | "pushCommunication" | "emailCommunication" | "emailMarketing" | "emailSecurity" | "smsCommunication" | "smsSecurity";
  pushBidding: boolean;
  pushWatchlist: boolean;
  pushPayments: boolean;
  pushCommunication: boolean;
  emailCommunication: boolean;
  emailMarketing: boolean;
  emailSecurity: boolean;
  smsCommunication: boolean;
  smsSecurity: boolean;
};



export type AngleAccountsNotificationPreferencesAttributesOnlySchema = {
  __type: "Resource";
  __primitiveFields: "pushBidding" | "pushWatchlist" | "pushPayments" | "pushCommunication" | "emailCommunication" | "emailMarketing" | "emailSecurity" | "smsCommunication" | "smsSecurity";
  pushBidding: boolean;
  pushWatchlist: boolean;
  pushPayments: boolean;
  pushCommunication: boolean;
  emailCommunication: boolean;
  emailMarketing: boolean;
  emailSecurity: boolean;
  smsCommunication: boolean;
  smsSecurity: boolean;
};


export type AngleAccountsNotificationPreferencesInputSchema = {
  pushBidding?: boolean;
  pushWatchlist?: boolean;
  pushPayments?: boolean;
  pushCommunication?: boolean;
  emailCommunication?: boolean;
  emailMarketing?: boolean;
  emailSecurity?: boolean;
  smsCommunication?: boolean;
  smsSecurity?: boolean;
};




export type BidFilterInput = {
  and?: Array<BidFilterInput>;
  or?: Array<BidFilterInput>;
  not?: Array<BidFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  amount?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  bidType?: {
    eq?: "auto" | "proxy" | "manual";
    notEq?: "auto" | "proxy" | "manual";
    in?: Array<"auto" | "proxy" | "manual">;
  };

  itemId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  bidTime?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };


  item?: ItemFilterInput;

  user?: UserFilterInput;

};
export type OrderFilterInput = {
  and?: Array<OrderFilterInput>;
  or?: Array<OrderFilterInput>;
  not?: Array<OrderFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  status?: {
    eq?: "payment_pending" | "paid" | "dispatched" | "completed" | "cancelled";
    notEq?: "payment_pending" | "paid" | "dispatched" | "completed" | "cancelled";
    in?: Array<"payment_pending" | "paid" | "dispatched" | "completed" | "cancelled">;
  };

  amount?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  paymentReference?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  paidAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  dispatchedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  completedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  createdAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  itemId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  buyerId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  sellerId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  item?: ItemFilterInput;

  buyer?: UserFilterInput;

  seller?: UserFilterInput;

  review?: ReviewFilterInput;

};
export type ReviewFilterInput = {
  and?: Array<ReviewFilterInput>;
  or?: Array<ReviewFilterInput>;
  not?: Array<ReviewFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  rating?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  comment?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  insertedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  orderId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  reviewerId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  sellerId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  order?: OrderFilterInput;

  reviewer?: UserFilterInput;

  seller?: UserFilterInput;

};
export type CategoryFilterInput = {
  and?: Array<CategoryFilterInput>;
  or?: Array<CategoryFilterInput>;
  not?: Array<CategoryFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  slug?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  attributeSchema?: {
    eq?: Array<AngleCatalogCategoryFieldResourceSchema>;
    notEq?: Array<AngleCatalogCategoryFieldResourceSchema>;
    in?: Array<Array<AngleCatalogCategoryFieldResourceSchema>>;
  };

  formSchema?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  imageUrl?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  parentId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  category?: CategoryFilterInput;

  categories?: CategoryFilterInput;

  items?: ItemFilterInput;

};
export type OptionSetFilterInput = {
  and?: Array<OptionSetFilterInput>;
  or?: Array<OptionSetFilterInput>;
  not?: Array<OptionSetFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  slug?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  parentId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  optionSetValues?: OptionSetValueFilterInput;

  parent?: OptionSetFilterInput;

  children?: OptionSetFilterInput;

};
export type OptionSetValueFilterInput = {
  and?: Array<OptionSetValueFilterInput>;
  or?: Array<OptionSetValueFilterInput>;
  not?: Array<OptionSetValueFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  value?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  label?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  metadata?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  sortOrder?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  isActive?: {
    eq?: boolean;
    notEq?: boolean;
  };

  parentSetId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  parentValue?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  optionSetId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  optionSet?: OptionSetFilterInput;

};
export type ItemFilterInput = {
  and?: Array<ItemFilterInput>;
  or?: Array<ItemFilterInput>;
  not?: Array<ItemFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  title?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  startingPrice?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  reservePrice?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  currentPrice?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  bidIncrement?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  slug?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  startTime?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  endTime?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  categoryId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  lotNumber?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  publicationStatus?: {
    eq?: "draft" | "pending" | "published" | "unpublished" | "archived";
    notEq?: "draft" | "pending" | "published" | "unpublished" | "archived";
    in?: Array<"draft" | "pending" | "published" | "unpublished" | "archived">;
  };

  auctionStatus?: {
    eq?: "pending" | "scheduled" | "active" | "paused" | "ended" | "sold" | "cancelled";
    notEq?: "pending" | "scheduled" | "active" | "paused" | "ended" | "sold" | "cancelled";
    in?: Array<"pending" | "scheduled" | "active" | "paused" | "ended" | "sold" | "cancelled">;
  };

  condition?: {
    eq?: "new" | "used" | "refurbished";
    notEq?: "new" | "used" | "refurbished";
    in?: Array<"new" | "used" | "refurbished">;
  };

  location?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  attributes?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  saleType?: {
    eq?: "auction" | "buy_now" | "hybrid";
    notEq?: "auction" | "buy_now" | "hybrid";
    in?: Array<"auction" | "buy_now" | "hybrid">;
  };

  auctionFormat?: {
    eq?: "standard" | "reserve" | "live" | "timed";
    notEq?: "standard" | "reserve" | "live" | "timed";
    in?: Array<"standard" | "reserve" | "live" | "timed">;
  };

  buyNowPrice?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  viewCount?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  createdById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  extensionCount?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  originalEndTime?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  bidCount?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  watcherCount?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  user?: UserFilterInput;

  category?: CategoryFilterInput;

};
export type WatchlistItemFilterInput = {
  and?: Array<WatchlistItemFilterInput>;
  or?: Array<WatchlistItemFilterInput>;
  not?: Array<WatchlistItemFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  itemId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  user?: UserFilterInput;

  item?: ItemFilterInput;

};
export type UserFilterInput = {
  and?: Array<UserFilterInput>;
  or?: Array<UserFilterInput>;
  not?: Array<UserFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  email?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  fullName?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  phoneNumber?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  username?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  location?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  whatsappNumber?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  autoCharge?: {
    eq?: boolean;
    notEq?: boolean;
  };

  notificationPreferences?: {
    eq?: AngleAccountsNotificationPreferencesResourceSchema;
    notEq?: AngleAccountsNotificationPreferencesResourceSchema;
    in?: Array<AngleAccountsNotificationPreferencesResourceSchema>;
  };

  createdAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  publishedItemCount?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  reviewCount?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  storeProfile?: StoreProfileFilterInput;

  items?: ItemFilterInput;

  receivedReviews?: ReviewFilterInput;

};
export type StoreProfileFilterInput = {
  and?: Array<StoreProfileFilterInput>;
  or?: Array<StoreProfileFilterInput>;
  not?: Array<StoreProfileFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  storeName?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  contactPhone?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  whatsappLink?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  location?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  address?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  deliveryPreference?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  user?: UserFilterInput;

};
export type AngleCatalogCategoryFieldFilterInput = {
  and?: Array<AngleCatalogCategoryFieldFilterInput>;
  or?: Array<AngleCatalogCategoryFieldFilterInput>;
  not?: Array<AngleCatalogCategoryFieldFilterInput>;

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  type?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  required?: {
    eq?: boolean;
    notEq?: boolean;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  optionSetSlug?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  options?: {
    eq?: Array<string>;
    notEq?: Array<string>;
    in?: Array<Array<string>>;
  };



};
export type AngleAccountsNotificationPreferencesFilterInput = {
  and?: Array<AngleAccountsNotificationPreferencesFilterInput>;
  or?: Array<AngleAccountsNotificationPreferencesFilterInput>;
  not?: Array<AngleAccountsNotificationPreferencesFilterInput>;

  pushBidding?: {
    eq?: boolean;
    notEq?: boolean;
  };

  pushWatchlist?: {
    eq?: boolean;
    notEq?: boolean;
  };

  pushPayments?: {
    eq?: boolean;
    notEq?: boolean;
  };

  pushCommunication?: {
    eq?: boolean;
    notEq?: boolean;
  };

  emailCommunication?: {
    eq?: boolean;
    notEq?: boolean;
  };

  emailMarketing?: {
    eq?: boolean;
    notEq?: boolean;
  };

  emailSecurity?: {
    eq?: boolean;
    notEq?: boolean;
  };

  smsCommunication?: {
    eq?: boolean;
    notEq?: boolean;
  };

  smsSecurity?: {
    eq?: boolean;
    notEq?: boolean;
  };



};


// Utility Types

// Resource schema constraint
export type TypedSchema = {
  __type: "Resource" | "TypedMap" | "Union";
  __primitiveFields: string;
};

// Utility type to convert union to intersection
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;

// Helper type to infer union field values, avoiding duplication between array and non-array unions
export type InferUnionFieldValue<
  UnionSchema extends { __type: "Union"; __primitiveFields: any },
  FieldSelection extends any[],
> = UnionToIntersection<
  {
    [FieldIndex in keyof FieldSelection]: FieldSelection[FieldIndex] extends UnionSchema["__primitiveFields"]
      ? FieldSelection[FieldIndex] extends keyof UnionSchema
        ? { [P in FieldSelection[FieldIndex]]: UnionSchema[FieldSelection[FieldIndex]] }
        : never
      : FieldSelection[FieldIndex] extends Record<string, any>
        ? {
            [UnionKey in keyof FieldSelection[FieldIndex]]: UnionKey extends keyof UnionSchema
              ? NonNullable<UnionSchema[UnionKey]> extends { __array: true; __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
                ? FieldSelection[FieldIndex][UnionKey] extends any[]
                  ? Array<
                      UnionToIntersection<
                        {
                          [FieldIdx in keyof FieldSelection[FieldIndex][UnionKey]]: FieldSelection[FieldIndex][UnionKey][FieldIdx] extends TypedMapFields
                            ? FieldSelection[FieldIndex][UnionKey][FieldIdx] extends keyof NonNullable<UnionSchema[UnionKey]>
                              ? { [P in FieldSelection[FieldIndex][UnionKey][FieldIdx]]: NonNullable<UnionSchema[UnionKey]>[P] }
                              : never
                            : never;
                        }[number]
                      >
                    > | null
                  : never
                : NonNullable<UnionSchema[UnionKey]> extends { __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
                  ? FieldSelection[FieldIndex][UnionKey] extends any[]
                    ? UnionToIntersection<
                        {
                          [FieldIdx in keyof FieldSelection[FieldIndex][UnionKey]]: FieldSelection[FieldIndex][UnionKey][FieldIdx] extends TypedMapFields
                            ? FieldSelection[FieldIndex][UnionKey][FieldIdx] extends keyof NonNullable<UnionSchema[UnionKey]>
                              ? { [P in FieldSelection[FieldIndex][UnionKey][FieldIdx]]: NonNullable<UnionSchema[UnionKey]>[P] }
                              : never
                            : never;
                        }[number]
                      > | null
                    : never
                  : NonNullable<UnionSchema[UnionKey]> extends TypedSchema
                    ? InferResult<NonNullable<UnionSchema[UnionKey]>, FieldSelection[FieldIndex][UnionKey]>
                    : never
              : never;
          }
        : never;
  }[number]
>;

export type HasComplexFields<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
> extends never
  ? false
  : true;

export type ComplexFieldKeys<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
>;

export type LeafFieldSelection<T extends TypedSchema> = T["__primitiveFields"];

export type ComplexFieldSelection<T extends TypedSchema> = {
  [K in ComplexFieldKeys<T>]?: T[K] extends {
    __type: "Relationship";
    __resource: infer Resource;
  }
    ? NonNullable<Resource> extends TypedSchema
      ? UnifiedFieldSelection<NonNullable<Resource>>[]
      : never
    : T[K] extends {
          __type: "ComplexCalculation";
          __returnType: infer ReturnType;
        }
      ? T[K] extends { __args: infer Args }
        ? NonNullable<ReturnType> extends TypedSchema
          ? {
              args: Args;
              fields: UnifiedFieldSelection<NonNullable<ReturnType>>[];
            }
          : { args: Args }
        : NonNullable<ReturnType> extends TypedSchema
          ? { fields: UnifiedFieldSelection<NonNullable<ReturnType>>[] }
          : never
      : T[K] extends { __type: "TypedMap" }
        ? NonNullable<T[K]> extends TypedSchema
          ? UnifiedFieldSelection<NonNullable<T[K]>>[]
          : never
        : T[K] extends { __type: "Union"; __primitiveFields: infer PrimitiveFields }
          ? T[K] extends { __array: true }
            ? (PrimitiveFields | {
                [UnionKey in keyof Omit<T[K], "__type" | "__primitiveFields" | "__array">]?: NonNullable<T[K][UnionKey]> extends { __type: "TypedMap"; __primitiveFields: any }
                  ? NonNullable<T[K][UnionKey]>["__primitiveFields"][]
                  : NonNullable<T[K][UnionKey]> extends TypedSchema
                    ? UnifiedFieldSelection<NonNullable<T[K][UnionKey]>>[]
                    : never;
              })[]
            : (PrimitiveFields | {
                [UnionKey in keyof Omit<T[K], "__type" | "__primitiveFields">]?: NonNullable<T[K][UnionKey]> extends { __type: "TypedMap"; __primitiveFields: any }
                  ? NonNullable<T[K][UnionKey]>["__primitiveFields"][]
                  : NonNullable<T[K][UnionKey]> extends TypedSchema
                    ? UnifiedFieldSelection<NonNullable<T[K][UnionKey]>>[]
                    : never;
              })[]
            : NonNullable<T[K]> extends TypedSchema
              ? UnifiedFieldSelection<NonNullable<T[K]>>[]
              : never;
};

// Main type: Use explicit base case detection to prevent infinite recursion
export type UnifiedFieldSelection<T extends TypedSchema> =
  HasComplexFields<T> extends false
    ? LeafFieldSelection<T> // Base case: only primitives, no recursion
    : LeafFieldSelection<T> | ComplexFieldSelection<T>; // Recursive case

export type InferFieldValue<
  T extends TypedSchema,
  Field,
> = Field extends T["__primitiveFields"]
  ? Field extends keyof T
    ? { [K in Field]: T[Field] }
    : never
  : Field extends Record<string, any>
    ? {
        [K in keyof Field]: K extends keyof T
          ? T[K] extends {
              __type: "Relationship";
              __resource: infer Resource;
            }
            ? NonNullable<Resource> extends TypedSchema
              ? T[K] extends { __array: true }
                ? Array<InferResult<NonNullable<Resource>, Field[K]>>
                : null extends Resource
                  ? InferResult<NonNullable<Resource>, Field[K]> | null
                  : InferResult<NonNullable<Resource>, Field[K]>
            : never
          : T[K] extends {
                __type: "ComplexCalculation";
                __returnType: infer ReturnType;
              }
            ? NonNullable<ReturnType> extends TypedSchema
              ? null extends ReturnType
                ? InferResult<NonNullable<ReturnType>, Field[K]["fields"]> | null
                : InferResult<NonNullable<ReturnType>, Field[K]["fields"]>
              : ReturnType
            : NonNullable<T[K]> extends { __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
              ? NonNullable<T[K]> extends { __array: true }
                ? Field[K] extends any[]
                  ? null extends T[K]
                    ? Array<
                        UnionToIntersection<
                          {
                            [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends infer E
                              ? E extends TypedMapFields
                                ? E extends keyof NonNullable<T[K]>
                                  ? { [P in E]: NonNullable<T[K]>[P] }
                                  : never
                                : E extends Record<string, any>
                                  ? {
                                      [NestedKey in keyof E]: NestedKey extends keyof NonNullable<T[K]>
                                        ? NonNullable<NonNullable<T[K]>[NestedKey]> extends TypedSchema
                                          ? null extends NonNullable<T[K]>[NestedKey]
                                            ? InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]> | null
                                            : InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]>
                                          : never
                                        : never;
                                    }
                                  : E extends keyof NonNullable<T[K]>
                                    ? { [P in E]: NonNullable<T[K]>[P] }
                                    : never
                              : never;
                          }[number]
                        >
                      > | null
                    : Array<
                        UnionToIntersection<
                          {
                            [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends infer E
                              ? E extends TypedMapFields
                                ? E extends keyof NonNullable<T[K]>
                                  ? { [P in E]: NonNullable<T[K]>[P] }
                                  : never
                                : E extends Record<string, any>
                                  ? {
                                      [NestedKey in keyof E]: NestedKey extends keyof NonNullable<T[K]>
                                        ? NonNullable<NonNullable<T[K]>[NestedKey]> extends TypedSchema
                                          ? null extends NonNullable<T[K]>[NestedKey]
                                            ? InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]> | null
                                            : InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]>
                                          : never
                                        : never;
                                    }
                                  : E extends keyof NonNullable<T[K]>
                                    ? { [P in E]: NonNullable<T[K]>[P] }
                                    : never
                              : never;
                          }[number]
                        >
                      >
                  : never
                : Field[K] extends any[]
                  ? null extends T[K]
                    ? UnionToIntersection<
                        {
                          [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends infer E
                            ? E extends TypedMapFields
                              ? E extends keyof NonNullable<T[K]>
                                ? { [P in E]: NonNullable<T[K]>[P] }
                                : never
                              : E extends Record<string, any>
                                ? {
                                    [NestedKey in keyof E]: NestedKey extends keyof NonNullable<T[K]>
                                      ? NonNullable<NonNullable<T[K]>[NestedKey]> extends TypedSchema
                                        ? null extends NonNullable<T[K]>[NestedKey]
                                          ? InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]> | null
                                          : InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]>
                                        : never
                                      : never;
                                  }
                                : E extends keyof NonNullable<T[K]>
                                  ? { [P in E]: NonNullable<T[K]>[P] }
                                  : never
                            : never;
                        }[number]
                      > | null
                    : UnionToIntersection<
                        {
                          [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends infer E
                            ? E extends TypedMapFields
                              ? E extends keyof T[K]
                                ? { [P in E]: T[K][P] }
                                : never
                              : E extends Record<string, any>
                                ? {
                                    [NestedKey in keyof E]: NestedKey extends keyof NonNullable<T[K]>
                                      ? NonNullable<NonNullable<T[K]>[NestedKey]> extends TypedSchema
                                        ? null extends NonNullable<T[K]>[NestedKey]
                                          ? InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]> | null
                                          : InferResult<NonNullable<NonNullable<T[K]>[NestedKey]>, E[NestedKey]>
                                        : never
                                      : never;
                                  }
                                : E extends keyof NonNullable<T[K]>
                                  ? { [P in E]: NonNullable<T[K]>[P] }
                                  : never
                            : never;
                        }[number]
                      >
                  : never
              : T[K] extends { __type: "Union"; __primitiveFields: any }
                ? T[K] extends { __array: true }
                  ? Field[K] extends any[]
                    ? null extends T[K]
                      ? Array<InferUnionFieldValue<T[K], Field[K]>> | null
                      : Array<InferUnionFieldValue<T[K], Field[K]>>
                    : never
                  : Field[K] extends any[]
                    ? null extends T[K]
                      ? InferUnionFieldValue<T[K], Field[K]> | null
                      : InferUnionFieldValue<T[K], Field[K]>
                    : never
                  : NonNullable<T[K]> extends TypedSchema
                    ? null extends T[K]
                      ? InferResult<NonNullable<T[K]>, Field[K]> | null
                      : InferResult<NonNullable<T[K]>, Field[K]>
                    : never
          : never;
      }
    : never;

export type InferResult<
  T extends TypedSchema,
  SelectedFields extends UnifiedFieldSelection<T>[] | undefined,
> = SelectedFields extends undefined
  ? {}
  : SelectedFields extends []
  ? {}
  : SelectedFields extends UnifiedFieldSelection<T>[]
  ? UnionToIntersection<
      {
        [K in keyof SelectedFields]: InferFieldValue<T, SelectedFields[K]>;
      }[number]
    >
  : {};

// Pagination conditional types
// Checks if a page configuration object has any pagination parameters
export type HasPaginationParams<Page> =
  Page extends { offset: any } ? true :
  Page extends { after: any } ? true :
  Page extends { before: any } ? true :
  false;

// Infer which pagination type is being used from the page config
export type InferPaginationType<Page> =
  Page extends { offset: any } ? "offset" :
  Page extends { after: any } | { before: any } ? "keyset" :
  never;

// Returns either non-paginated (array) or paginated result based on page params
// For single pagination type support (offset-only or keyset-only)
// @ts-ignore
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export type ConditionalPaginatedResult<
  Page,
  RecordType,
  PaginatedType
> = Page extends undefined
  ? RecordType
  : HasPaginationParams<Page> extends true
    ? PaginatedType
    : RecordType;

// For actions supporting both offset and keyset pagination
// Infers the specific pagination type based on which params were passed
export type ConditionalPaginatedResultMixed<
  Page,
  RecordType,
  OffsetType,
  KeysetType
> = Page extends undefined
  ? RecordType
  : HasPaginationParams<Page> extends true
    ? InferPaginationType<Page> extends "offset"
      ? OffsetType
      : InferPaginationType<Page> extends "keyset"
        ? KeysetType
        : OffsetType | KeysetType  // Fallback to union if can't determine
    : RecordType;

export type SuccessDataFunc<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: true }
>["data"];


export type ErrorData<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: false }
>["errors"];

/**
 * Represents an error from an unsuccessful RPC call.
 *
 * This type matches the error structure defined in the AshTypescript.Rpc.Error protocol.
 *
 * @example
 * const error: AshRpcError = {
 *   type: "invalid_changes",
 *   message: "Invalid value for field %{field}",
 *   shortMessage: "Invalid changes",
 *   vars: { field: "email" },
 *   fields: ["email"],
 *   path: ["user", "email"],
 *   details: { suggestion: "Provide a valid email address" }
 * }
 */
export type AshRpcError = {
  /** Machine-readable error type (e.g., "invalid_changes", "not_found") */
  type: string;
  /** Full error message (may contain template variables like %{key}) */
  message: string;
  /** Concise version of the message */
  shortMessage: string;
  /** Variables to interpolate into the message template */
  vars: Record<string, any>;
  /** List of affected field names (for field-level errors) */
  fields: string[];
  /** Path to the error location in the data structure */
  path: string[];
  /** Optional map with extra details (e.g., suggestions, hints) */
  details?: Record<string, any>;
}

/**
 * Represents the result of a validation RPC call.
 *
 * All validation actions return this same structure, indicating either
 * successful validation or a list of validation errors.
 *
 * @example
 * // Successful validation
 * const result: ValidationResult = { success: true };
 *
 * // Failed validation
 * const result: ValidationResult = {
 *   success: false,
 *   errors: [
 *     {
 *       type: "required",
 *       message: "is required",
 *       shortMessage: "Required field",
 *       vars: { field: "email" },
 *       fields: ["email"],
 *       path: []
 *     }
 *   ]
 * };
 */
export type ValidationResult =
  | { success: true }
  | { success: false; errors: AshRpcError[]; };





// Helper Functions

/**
 * Configuration options for action RPC requests
 */
export interface ActionConfig {
  // Request data
  input?: Record<string, any>;
  identity?: any;
  fields?: Array<string | Record<string, any>>; // Field selection
  filter?: Record<string, any>; // Filter options (for reads)
  sort?: string; // Sort options
  page?:
    | {
        // Offset-based pagination
        limit?: number;
        offset?: number;
        count?: boolean;
      }
    | {
        // Keyset pagination
        limit?: number;
        after?: string;
        before?: string;
      };

  // Metadata
  metadataFields?: ReadonlyArray<string>;

  // HTTP customization
  headers?: Record<string, string>; // Custom headers
  fetchOptions?: RequestInit; // Fetch options (signal, cache, etc.)
  customFetch?: (
    input: RequestInfo | URL,
    init?: RequestInit,
  ) => Promise<Response>;

  // Multitenancy
  tenant?: string; // Tenant parameter

  // Hook context
  hookCtx?: Record<string, any>;
}

/**
 * Configuration options for validation RPC requests
 */
export interface ValidationConfig {
  // Request data
  input?: Record<string, any>;

  // HTTP customization
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (
    input: RequestInfo | URL,
    init?: RequestInit,
  ) => Promise<Response>;

  // Hook context
  hookCtx?: Record<string, any>;
}




/**
 * Gets the CSRF token from the page's meta tag
 * Returns null if no CSRF token is found
 */
export function getPhoenixCSRFToken(): string | null {
  return document
    ?.querySelector("meta[name='csrf-token']")
    ?.getAttribute("content") || null;
}

/**
 * Builds headers object with CSRF token for Phoenix applications
 * Returns headers object with X-CSRF-Token (if available)
 */
export function buildCSRFHeaders(headers: Record<string, string> = {}): Record<string, string> {
  const csrfToken = getPhoenixCSRFToken();
  if (csrfToken) {
    headers["X-CSRF-Token"] = csrfToken;
  }

  return headers;
}

/**
 * Internal helper function for making action RPC requests
 * Handles hooks, request configuration, fetch execution, and error handling
 * @param config Configuration matching ActionConfig
 */
export async function executeActionRpcRequest<T>(
  payload: Record<string, any>,
  config: ActionConfig
): Promise<T> {
    const processedConfig = config;

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/run", fetchOptions);
  const result = response.ok ? await response.json() : null;


  if (!response.ok) {
    return {
      success: false,
      errors: [
        {
          type: "network_error",
          message: `Network request failed: ${response.statusText}`,
          shortMessage: "Network error",
          vars: { statusCode: response.status, statusText: response.statusText },
          fields: [],
          path: [],
          details: { statusCode: response.status }
        }
      ],
    } as T;
  }

  return result as T;
}


/**
 * Internal helper function for making validation RPC requests
 * Handles hooks, request configuration, fetch execution, and error handling
 * @param config Configuration matching ValidationConfig
 */
export async function executeValidationRpcRequest<T>(
  payload: Record<string, any>,
  config: ValidationConfig
): Promise<T> {
    const processedConfig = config;

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...processedConfig.headers,
    ...config.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...processedConfig.fetchOptions,
    ...config.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/rpc/validate", fetchOptions);
  const result = response.ok ? await response.json() : null;


  if (!response.ok) {
    return {
      success: false,
      errors: [
        {
          type: "network_error",
          message: `Network request failed: ${response.statusText}`,
          shortMessage: "Network error",
          vars: { statusCode: response.status, statusText: response.statusText },
          fields: [],
          path: [],
          details: { statusCode: response.status }
        }
      ],
    } as T;
  }

  return result as T;
}







// ============================
// Typed Queries
// ============================
// Use these types and field constants for server-side rendering and data fetching.
// The field constants can be used with the corresponding RPC actions for client-side refetching.

// Item Typed Queries
/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export type HomepageItemCard = Array<InferResult<ItemResourceSchema, ["id", "title", "slug", "startingPrice", "currentPrice", "endTime", "auctionStatus", "condition", "saleType", "viewCount", { category: ["id", "name", "slug"] }]>>;

/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export const homepageItemCardFields = ["id", "title", "slug", "startingPrice", "currentPrice", "endTime", "auctionStatus", "condition", "saleType", "viewCount", { category: ["id", "name", "slug"] }] satisfies ListItemsFields;


/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export type CategoryItemCard = Array<InferResult<ItemResourceSchema, ["id", "title", "slug", "startingPrice", "currentPrice", "endTime", "auctionStatus", "condition", "saleType", "viewCount", "bidCount", { category: ["id", "name", "slug"] }]>>;

/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export const categoryItemCardFields = ["id", "title", "slug", "startingPrice", "currentPrice", "endTime", "auctionStatus", "condition", "saleType", "viewCount", "bidCount", { category: ["id", "name", "slug"] }];


/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export type SellerItemCard = Array<InferResult<ItemResourceSchema, ["id", "title", "slug", "startingPrice", "currentPrice", "endTime", "auctionStatus", "condition", "saleType", "viewCount", "bidCount", { category: ["id", "name", "slug"] }]>>;

/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export const sellerItemCardFields = ["id", "title", "slug", "startingPrice", "currentPrice", "endTime", "auctionStatus", "condition", "saleType", "viewCount", "bidCount", { category: ["id", "name", "slug"] }];


/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export type ItemDetail = Array<InferResult<ItemResourceSchema, ["id", "title", "description", "slug", "startingPrice", "currentPrice", "reservePrice", "bidIncrement", "buyNowPrice", "endTime", "startTime", "auctionStatus", "publicationStatus", "condition", "saleType", "auctionFormat", "viewCount", "location", "attributes", "lotNumber", "createdById", "bidCount", { category: ["id", "name", "slug"] }]>>;

/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export const itemDetailFields = ["id", "title", "description", "slug", "startingPrice", "currentPrice", "reservePrice", "bidIncrement", "buyNowPrice", "endTime", "startTime", "auctionStatus", "publicationStatus", "condition", "saleType", "auctionFormat", "viewCount", "location", "attributes", "lotNumber", "createdById", "bidCount", { category: ["id", "name", "slug"] }] satisfies ListItemsFields;


/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export type WatchlistItemCard = Array<InferResult<ItemResourceSchema, ["id", "title", "slug", "startingPrice", "currentPrice", "endTime", "auctionStatus", "condition", "saleType", "bidCount", "watcherCount", { category: ["id", "name", "slug"] }, { user: ["id", "fullName"] }]>>;

/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export const watchlistItemCardFields = ["id", "title", "slug", "startingPrice", "currentPrice", "endTime", "auctionStatus", "condition", "saleType", "bidCount", "watcherCount", { category: ["id", "name", "slug"] }, { user: ["id", "fullName"] }];


/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export type UserWatchlistId = Array<InferResult<ItemResourceSchema, ["id"]>>;

/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export const userWatchlistIdFields = ["id"];


/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export type SellerDashboardCard = Array<InferResult<ItemResourceSchema, ["id", "title", "slug", "startingPrice", "currentPrice", "endTime", "auctionStatus", "publicationStatus", "condition", "saleType", "viewCount", "bidCount", "watcherCount", { category: ["id", "name"] }]>>;

/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export const sellerDashboardCardFields = ["id", "title", "slug", "startingPrice", "currentPrice", "endTime", "auctionStatus", "publicationStatus", "condition", "saleType", "viewCount", "bidCount", "watcherCount", { category: ["id", "name"] }] satisfies ListMyListingsFields;


/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export type SearchItemCard = Array<InferResult<ItemResourceSchema, ["id", "title", "slug", "description", "startingPrice", "currentPrice", "endTime", "auctionStatus", "condition", "saleType", "location", "viewCount", "bidCount", { category: ["id", "name", "slug"] }]>>;

/**
 * Typed query for Item
 *
 * @typedQuery true
 */
export const searchItemCardFields = ["id", "title", "slug", "description", "startingPrice", "currentPrice", "endTime", "auctionStatus", "condition", "saleType", "location", "viewCount", "bidCount", { category: ["id", "name", "slug"] }];



// Review Typed Queries
/**
 * Typed query for Review
 *
 * @typedQuery true
 */
export type SellerReviewCard = Array<InferResult<ReviewResourceSchema, ["id", "rating", "comment", "insertedAt", { reviewer: ["id", "username", "fullName"] }]>>;

/**
 * Typed query for Review
 *
 * @typedQuery true
 */
export const sellerReviewCardFields = ["id", "rating", "comment", "insertedAt", { reviewer: ["id", "username", "fullName"] }] satisfies ListReviewsBySellerFields;



// User Typed Queries
/**
 * Typed query for User
 *
 * @typedQuery true
 */
export type SellerProfile = Array<InferResult<UserResourceSchema, ["id", "username", "fullName", "location", "phoneNumber", "whatsappNumber", "createdAt", "publishedItemCount", "avgRating", "reviewCount", { storeProfile: ["storeName", "location", "contactPhone", "whatsappLink", "deliveryPreference"] }]>>;

/**
 * Typed query for User
 *
 * @typedQuery true
 */
export const sellerProfileFields = ["id", "username", "fullName", "location", "phoneNumber", "whatsappNumber", "createdAt", "publishedItemCount", "avgRating", "reviewCount", { storeProfile: ["storeName", "location", "contactPhone", "whatsappLink", "deliveryPreference"] }];



// Bid Typed Queries
/**
 * Typed query for Bid
 *
 * @typedQuery true
 */
export type ActiveBidCard = Array<InferResult<BidResourceSchema, ["id", "amount", "bidType", "bidTime", "itemId", "userId", { item: ["id", "title", "slug", "currentPrice", "startingPrice", "endTime", "auctionStatus", "bidCount", "watcherCount"] }]>>;

/**
 * Typed query for Bid
 *
 * @typedQuery true
 */
export const activeBidCardFields = ["id", "amount", "bidType", "bidTime", "itemId", "userId", { item: ["id", "title", "slug", "currentPrice", "startingPrice", "endTime", "auctionStatus", "bidCount", "watcherCount"] }] satisfies ListBidsFields;


/**
 * Typed query for Bid
 *
 * @typedQuery true
 */
export type HistoryBidCard = Array<InferResult<BidResourceSchema, ["id", "amount", "bidTime", "itemId", "userId", { item: ["id", "title", "slug", "auctionStatus", "createdById", { user: ["id", "username", "fullName"] }] }]>>;

/**
 * Typed query for Bid
 *
 * @typedQuery true
 */
export const historyBidCardFields = ["id", "amount", "bidTime", "itemId", "userId", { item: ["id", "title", "slug", "auctionStatus", "createdById", { user: ["id", "username", "fullName"] }] }] satisfies ListBidsFields;



// Order Typed Queries
/**
 * Typed query for Order
 *
 * @typedQuery true
 */
export type WonOrderCard = Array<InferResult<OrderResourceSchema, ["id", "status", "amount", "paymentReference", "paidAt", "dispatchedAt", "completedAt", "createdAt", { item: ["id", "title", "slug"] }, { seller: ["id", "username", "fullName", "whatsappNumber"] }]>>;

/**
 * Typed query for Order
 *
 * @typedQuery true
 */
export const wonOrderCardFields = ["id", "status", "amount", "paymentReference", "paidAt", "dispatchedAt", "completedAt", "createdAt", { item: ["id", "title", "slug"] }, { seller: ["id", "username", "fullName", "whatsappNumber"] }] satisfies ListOrdersFields;


/**
 * Typed query for Order
 *
 * @typedQuery true
 */
export type SellerPaymentCard = Array<InferResult<OrderResourceSchema, ["id", "status", "amount", "paymentReference", "createdAt", { item: ["id", "title"] }]>>;

/**
 * Typed query for Order
 *
 * @typedQuery true
 */
export const sellerPaymentCardFields = ["id", "status", "amount", "paymentReference", "createdAt", { item: ["id", "title"] }] satisfies ListSellerOrdersFields;



// Category Typed Queries
/**
 * Typed query for Category
 *
 * @typedQuery true
 */
export type HomepageCategory = Array<InferResult<CategoryResourceSchema, ["id", "name", "slug", "imageUrl"]>>;

/**
 * Typed query for Category
 *
 * @typedQuery true
 */
export const homepageCategoryFields = ["id", "name", "slug", "imageUrl"] satisfies ListCategoriesFields;


/**
 * Typed query for Category
 *
 * @typedQuery true
 */
export type NavCategory = Array<InferResult<CategoryResourceSchema, ["id", "name", "slug", { categories: ["id", "name", "slug"] }]>>;

/**
 * Typed query for Category
 *
 * @typedQuery true
 */
export const navCategoryFields = ["id", "name", "slug", { categories: ["id", "name", "slug"] }];


/**
 * Typed query for Category
 *
 * @typedQuery true
 */
export type ListingFormCategory = Array<InferResult<CategoryResourceSchema, ["id", "name", "slug", { attributeSchema: ["name", "type", "required", "description", "optionSetSlug", "options"] }, { categories: ["id", "name", "slug", { attributeSchema: ["name", "type", "required", "description", "optionSetSlug", "options"] }] }]>>;

/**
 * Typed query for Category
 *
 * @typedQuery true
 */
export const listingFormCategoryFields = ["id", "name", "slug", { attributeSchema: ["name", "type", "required", "description", "optionSetSlug", "options"] }, { categories: ["id", "name", "slug", { attributeSchema: ["name", "type", "required", "description", "optionSetSlug", "options"] }] }];




export type ListBidsFields = UnifiedFieldSelection<BidResourceSchema>[];


export type InferListBidsResult<
  Fields extends ListBidsFields | undefined,
  Page extends ListBidsConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<BidResourceSchema, Fields>>, {
  results: Array<InferResult<BidResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<BidResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListBidsConfig = {
  tenant?: string;
  fields: ListBidsFields;
  filter?: BidFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListBidsResult<Fields extends ListBidsFields, Page extends ListBidsConfig["page"] = undefined> = | { success: true; data: InferListBidsResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Bid records
 *
 * @ashActionType :read
 */
export async function listBids<Fields extends ListBidsFields, Config extends ListBidsConfig = ListBidsConfig>(
  config: Config & { fields: Fields }
): Promise<ListBidsResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_bids",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListBidsResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read Bid records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListBids(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_bids",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type MakeBidInput = {
  amount: Decimal;
  bidType: "auto" | "proxy" | "manual";
  itemId: UUID;
};

export type MakeBidFields = UnifiedFieldSelection<BidResourceSchema>[];

export type InferMakeBidResult<
  Fields extends MakeBidFields | undefined,
> = InferResult<BidResourceSchema, Fields>;

export type MakeBidResult<Fields extends MakeBidFields | undefined = undefined> = | { success: true; data: InferMakeBidResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new Bid
 *
 * @ashActionType :create
 */
export async function makeBid<Fields extends MakeBidFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: MakeBidInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MakeBidResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "make_bid",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<MakeBidResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new Bid
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateMakeBid(
  config: {
  tenant?: string;
  input: MakeBidInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "make_bid",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListOrdersFields = UnifiedFieldSelection<OrderResourceSchema>[];


export type InferListOrdersResult<
  Fields extends ListOrdersFields | undefined,
  Page extends ListOrdersConfig["page"] = undefined
> = ConditionalPaginatedResult<Page, Array<InferResult<OrderResourceSchema, Fields>>, {
  results: Array<InferResult<OrderResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}>;

export type ListOrdersConfig = {
  tenant?: string;
  fields: ListOrdersFields;
  filter?: OrderFilterInput;
  sort?: string;
  page?: {
    limit?: number;
    offset?: number;
    after?: never;
    before?: never;
    count?: boolean;
  };
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListOrdersResult<Fields extends ListOrdersFields, Page extends ListOrdersConfig["page"] = undefined> = | { success: true; data: InferListOrdersResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Order records
 *
 * @ashActionType :read
 */
export async function listOrders<Fields extends ListOrdersFields, Config extends ListOrdersConfig = ListOrdersConfig>(
  config: Config & { fields: Fields }
): Promise<ListOrdersResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_orders",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListOrdersResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read Order records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListOrders(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_orders",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type PayOrderInput = {
  paymentReference: string;
};

export type PayOrderFields = UnifiedFieldSelection<OrderResourceSchema>[];

export type InferPayOrderResult<
  Fields extends PayOrderFields | undefined,
> = InferResult<OrderResourceSchema, Fields>;

export type PayOrderResult<Fields extends PayOrderFields | undefined = undefined> = | { success: true; data: InferPayOrderResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing Order
 *
 * @ashActionType :update
 */
export async function payOrder<Fields extends PayOrderFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: PayOrderInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<PayOrderResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "pay_order",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<PayOrderResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing Order
 *
 * @ashActionType :update
 * @validation true
 */
export async function validatePayOrder(
  config: {
  tenant?: string;
  identity: UUID | string;
  input: PayOrderInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "pay_order",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type MarkDispatchedFields = UnifiedFieldSelection<OrderResourceSchema>[];

export type InferMarkDispatchedResult<
  Fields extends MarkDispatchedFields | undefined,
> = InferResult<OrderResourceSchema, Fields>;

export type MarkDispatchedResult<Fields extends MarkDispatchedFields | undefined = undefined> = | { success: true; data: InferMarkDispatchedResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing Order
 *
 * @ashActionType :update
 */
export async function markDispatched<Fields extends MarkDispatchedFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MarkDispatchedResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "mark_dispatched",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<MarkDispatchedResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing Order
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateMarkDispatched(
  config: {
  tenant?: string;
  identity: UUID | string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "mark_dispatched",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ConfirmReceiptFields = UnifiedFieldSelection<OrderResourceSchema>[];

export type InferConfirmReceiptResult<
  Fields extends ConfirmReceiptFields | undefined,
> = InferResult<OrderResourceSchema, Fields>;

export type ConfirmReceiptResult<Fields extends ConfirmReceiptFields | undefined = undefined> = | { success: true; data: InferConfirmReceiptResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing Order
 *
 * @ashActionType :update
 */
export async function confirmReceipt<Fields extends ConfirmReceiptFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ConfirmReceiptResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "confirm_receipt",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ConfirmReceiptResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing Order
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateConfirmReceipt(
  config: {
  tenant?: string;
  identity: UUID | string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "confirm_receipt",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListSellerOrdersFields = UnifiedFieldSelection<OrderResourceSchema>[];


export type InferListSellerOrdersResult<
  Fields extends ListSellerOrdersFields | undefined,
  Page extends ListSellerOrdersConfig["page"] = undefined
> = ConditionalPaginatedResult<Page, Array<InferResult<OrderResourceSchema, Fields>>, {
  results: Array<InferResult<OrderResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}>;

export type ListSellerOrdersConfig = {
  tenant?: string;
  fields: ListSellerOrdersFields;
  filter?: OrderFilterInput;
  sort?: string;
  page?: {
    limit?: number;
    offset?: number;
    after?: never;
    before?: never;
    count?: boolean;
  };
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListSellerOrdersResult<Fields extends ListSellerOrdersFields, Page extends ListSellerOrdersConfig["page"] = undefined> = | { success: true; data: InferListSellerOrdersResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Order records
 *
 * @ashActionType :read
 */
export async function listSellerOrders<Fields extends ListSellerOrdersFields, Config extends ListSellerOrdersConfig = ListSellerOrdersConfig>(
  config: Config & { fields: Fields }
): Promise<ListSellerOrdersResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_seller_orders",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListSellerOrdersResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read Order records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListSellerOrders(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_seller_orders",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type CreateReviewInput = {
  orderId: UUID;
  rating: number;
  comment?: string | null;
};

export type CreateReviewFields = UnifiedFieldSelection<ReviewResourceSchema>[];

export type InferCreateReviewResult<
  Fields extends CreateReviewFields | undefined,
> = InferResult<ReviewResourceSchema, Fields>;

export type CreateReviewResult<Fields extends CreateReviewFields | undefined = undefined> = | { success: true; data: InferCreateReviewResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new Review
 *
 * @ashActionType :create
 */
export async function createReview<Fields extends CreateReviewFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateReviewInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateReviewResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_review",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateReviewResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new Review
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateCreateReview(
  config: {
  tenant?: string;
  input: CreateReviewInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "create_review",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type UpdateReviewInput = {
  rating?: number;
  comment?: string | null;
};

export type UpdateReviewFields = UnifiedFieldSelection<ReviewResourceSchema>[];

export type InferUpdateReviewResult<
  Fields extends UpdateReviewFields | undefined,
> = InferResult<ReviewResourceSchema, Fields>;

export type UpdateReviewResult<Fields extends UpdateReviewFields | undefined = undefined> = | { success: true; data: InferUpdateReviewResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing Review
 *
 * @ashActionType :update
 */
export async function updateReview<Fields extends UpdateReviewFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: UpdateReviewInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateReviewResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_review",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateReviewResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing Review
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateUpdateReview(
  config: {
  tenant?: string;
  identity: UUID | string;
  input: UpdateReviewInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "update_review",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListReviewsBySellerInput = {
  sellerId: UUID;
};

export type ListReviewsBySellerFields = UnifiedFieldSelection<ReviewResourceSchema>[];


export type InferListReviewsBySellerResult<
  Fields extends ListReviewsBySellerFields | undefined,
  Page extends ListReviewsBySellerConfig["page"] = undefined
> = ConditionalPaginatedResult<Page, Array<InferResult<ReviewResourceSchema, Fields>>, {
  results: Array<InferResult<ReviewResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}>;

export type ListReviewsBySellerConfig = {
  tenant?: string;
  input: ListReviewsBySellerInput;
  fields: ListReviewsBySellerFields;
  filter?: ReviewFilterInput;
  sort?: string;
  page?: {
    limit?: number;
    offset?: number;
    after?: never;
    before?: never;
    count?: boolean;
  };
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListReviewsBySellerResult<Fields extends ListReviewsBySellerFields, Page extends ListReviewsBySellerConfig["page"] = undefined> = | { success: true; data: InferListReviewsBySellerResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Review records
 *
 * @ashActionType :read
 */
export async function listReviewsBySeller<Fields extends ListReviewsBySellerFields, Config extends ListReviewsBySellerConfig = ListReviewsBySellerConfig>(
  config: Config & { fields: Fields }
): Promise<ListReviewsBySellerResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_reviews_by_seller",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListReviewsBySellerResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read Review records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListReviewsBySeller(
  config: {
  tenant?: string;
  input: ListReviewsBySellerInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_reviews_by_seller",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type GetReviewForOrderInput = {
  orderId: UUID;
};

export type GetReviewForOrderFields = UnifiedFieldSelection<ReviewResourceSchema>[];
export type InferGetReviewForOrderResult<
  Fields extends GetReviewForOrderFields,
> = Array<InferResult<ReviewResourceSchema, Fields>>;

export type GetReviewForOrderResult<Fields extends GetReviewForOrderFields> = | { success: true; data: InferGetReviewForOrderResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Review records
 *
 * @ashActionType :read
 */
export async function getReviewForOrder<Fields extends GetReviewForOrderFields>(
  config: {
  tenant?: string;
  input: GetReviewForOrderInput;
  fields: Fields;
  filter?: ReviewFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GetReviewForOrderResult<Fields>> {
  const payload = {
    action: "get_review_for_order",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<GetReviewForOrderResult<Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Read Review records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateGetReviewForOrder(
  config: {
  tenant?: string;
  input: GetReviewForOrderInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "get_review_for_order",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListCategoriesFields = UnifiedFieldSelection<CategoryResourceSchema>[];


export type InferListCategoriesResult<
  Fields extends ListCategoriesFields | undefined,
  Page extends ListCategoriesConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<CategoryResourceSchema, Fields>>, {
  results: Array<InferResult<CategoryResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<CategoryResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListCategoriesConfig = {
  tenant?: string;
  fields: ListCategoriesFields;
  filter?: CategoryFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListCategoriesResult<Fields extends ListCategoriesFields, Page extends ListCategoriesConfig["page"] = undefined> = | { success: true; data: InferListCategoriesResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Category records
 *
 * @ashActionType :read
 */
export async function listCategories<Fields extends ListCategoriesFields, Config extends ListCategoriesConfig = ListCategoriesConfig>(
  config: Config & { fields: Fields }
): Promise<ListCategoriesResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_categories",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListCategoriesResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read Category records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListCategories(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_categories",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type CreateCategoryInput = {
  name: string;
  description?: string | null;
  slug?: string | null;
  attributeSchema?: Array<AngleCatalogCategoryFieldInputSchema>;
  formSchema?: Record<string, any>;
  imageUrl?: string | null;
  parentId?: UUID | null;
};

export type CreateCategoryFields = UnifiedFieldSelection<CategoryResourceSchema>[];

export type InferCreateCategoryResult<
  Fields extends CreateCategoryFields | undefined,
> = InferResult<CategoryResourceSchema, Fields>;

export type CreateCategoryResult<Fields extends CreateCategoryFields | undefined = undefined> = | { success: true; data: InferCreateCategoryResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new Category
 *
 * @ashActionType :create
 */
export async function createCategory<Fields extends CreateCategoryFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateCategoryInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateCategoryResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_category",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateCategoryResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new Category
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateCreateCategory(
  config: {
  tenant?: string;
  input: CreateCategoryInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "create_category",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListOptionSetsFields = UnifiedFieldSelection<OptionSetResourceSchema>[];
export type InferListOptionSetsResult<
  Fields extends ListOptionSetsFields,
> = Array<InferResult<OptionSetResourceSchema, Fields>>;

export type ListOptionSetsResult<Fields extends ListOptionSetsFields> = | { success: true; data: InferListOptionSetsResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read OptionSet records
 *
 * @ashActionType :read
 */
export async function listOptionSets<Fields extends ListOptionSetsFields>(
  config: {
  tenant?: string;
  fields: Fields;
  filter?: OptionSetFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ListOptionSetsResult<Fields>> {
  const payload = {
    action: "list_option_sets",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<ListOptionSetsResult<Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Read OptionSet records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListOptionSets(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_option_sets",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListItemsFields = UnifiedFieldSelection<ItemResourceSchema>[];


export type InferListItemsResult<
  Fields extends ListItemsFields | undefined,
  Page extends ListItemsConfig["page"] = undefined
> = ConditionalPaginatedResult<Page, Array<InferResult<ItemResourceSchema, Fields>>, {
  results: Array<InferResult<ItemResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}>;

export type ListItemsConfig = {
  tenant?: string;
  fields: ListItemsFields;
  filter?: ItemFilterInput;
  sort?: string;
  page?: {
    limit?: number;
    offset?: number;
    after?: never;
    before?: never;
    count?: boolean;
  };
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListItemsResult<Fields extends ListItemsFields, Page extends ListItemsConfig["page"] = undefined> = | { success: true; data: InferListItemsResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Item records
 *
 * @ashActionType :read
 */
export async function listItems<Fields extends ListItemsFields, Config extends ListItemsConfig = ListItemsConfig>(
  config: Config & { fields: Fields }
): Promise<ListItemsResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_items",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListItemsResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read Item records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListItems(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_items",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type CreateDraftItemInput = {
  title: string;
  description?: string | null;
  startingPrice: Decimal;
  reservePrice?: Decimal | null;
  bidIncrement?: Decimal | null;
  slug?: string | null;
  startTime?: UtcDateTimeUsec | null;
  endTime?: UtcDateTimeUsec | null;
  categoryId?: UUID | null;
  lotNumber?: string | null;
  condition?: "new" | "used" | "refurbished" | null;
  location?: string | null;
  attributes?: Record<string, any>;
  saleType?: "auction" | "buy_now" | "hybrid";
  auctionFormat?: "standard" | "reserve" | "live" | "timed" | null;
  buyNowPrice?: Decimal | null;
};

export type CreateDraftItemFields = UnifiedFieldSelection<ItemResourceSchema>[];

export type InferCreateDraftItemResult<
  Fields extends CreateDraftItemFields | undefined,
> = InferResult<ItemResourceSchema, Fields>;

export type CreateDraftItemResult<Fields extends CreateDraftItemFields | undefined = undefined> = | { success: true; data: InferCreateDraftItemResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new Item
 *
 * @ashActionType :create
 */
export async function createDraftItem<Fields extends CreateDraftItemFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: CreateDraftItemInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CreateDraftItemResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "create_draft_item",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CreateDraftItemResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new Item
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateCreateDraftItem(
  config: {
  tenant?: string;
  input: CreateDraftItemInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "create_draft_item",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type UpdateDraftItemInput = {
  title?: string;
  description?: string | null;
  startingPrice?: Decimal;
  reservePrice?: Decimal | null;
  bidIncrement?: Decimal | null;
  slug?: string | null;
  startTime?: UtcDateTimeUsec | null;
  endTime?: UtcDateTimeUsec | null;
  categoryId?: UUID | null;
  lotNumber?: string | null;
  condition?: "new" | "used" | "refurbished" | null;
  location?: string | null;
  attributes?: Record<string, any>;
  saleType?: "auction" | "buy_now" | "hybrid";
  auctionFormat?: "standard" | "reserve" | "live" | "timed" | null;
  buyNowPrice?: Decimal | null;
  id: UUID;
};

export type UpdateDraftItemFields = UnifiedFieldSelection<ItemResourceSchema>[];

export type InferUpdateDraftItemResult<
  Fields extends UpdateDraftItemFields | undefined,
> = InferResult<ItemResourceSchema, Fields>;

export type UpdateDraftItemResult<Fields extends UpdateDraftItemFields | undefined = undefined> = | { success: true; data: InferUpdateDraftItemResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing Item
 *
 * @ashActionType :update
 */
export async function updateDraftItem<Fields extends UpdateDraftItemFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: UpdateDraftItemInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateDraftItemResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_draft_item",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateDraftItemResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing Item
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateUpdateDraftItem(
  config: {
  tenant?: string;
  identity: UUID | string;
  input: UpdateDraftItemInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "update_draft_item",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type PublishItemFields = UnifiedFieldSelection<ItemResourceSchema>[];

export type InferPublishItemResult<
  Fields extends PublishItemFields | undefined,
> = InferResult<ItemResourceSchema, Fields>;

export type PublishItemResult<Fields extends PublishItemFields | undefined = undefined> = | { success: true; data: InferPublishItemResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing Item
 *
 * @ashActionType :update
 */
export async function publishItem<Fields extends PublishItemFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<PublishItemResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "publish_item",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<PublishItemResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing Item
 *
 * @ashActionType :update
 * @validation true
 */
export async function validatePublishItem(
  config: {
  tenant?: string;
  identity: UUID | string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "publish_item",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListMyListingsInput = {
  statusFilter?: "all" | "active" | "ended" | "draft";
  sortField?: "inserted_at" | "view_count" | "bid_count" | "watcher_count" | "current_price";
  sortDir?: "asc" | "desc";
  query?: string;
};

export type ListMyListingsFields = UnifiedFieldSelection<ItemResourceSchema>[];


export type InferListMyListingsResult<
  Fields extends ListMyListingsFields | undefined,
  Page extends ListMyListingsConfig["page"] = undefined
> = ConditionalPaginatedResult<Page, Array<InferResult<ItemResourceSchema, Fields>>, {
  results: Array<InferResult<ItemResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}>;

export type ListMyListingsConfig = {
  tenant?: string;
  input?: ListMyListingsInput;
  fields: ListMyListingsFields;
  filter?: ItemFilterInput;
  sort?: string;
  page?: {
    limit?: number;
    offset?: number;
    after?: never;
    before?: never;
    count?: boolean;
  };
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListMyListingsResult<Fields extends ListMyListingsFields, Page extends ListMyListingsConfig["page"] = undefined> = | { success: true; data: InferListMyListingsResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read Item records
 *
 * @ashActionType :read
 */
export async function listMyListings<Fields extends ListMyListingsFields, Config extends ListMyListingsConfig = ListMyListingsConfig>(
  config: Config & { fields: Fields }
): Promise<ListMyListingsResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_my_listings",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListMyListingsResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read Item records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListMyListings(
  config: {
  tenant?: string;
  input?: ListMyListingsInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_my_listings",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type AddToWatchlistInput = {
  itemId: UUID;
};

export type AddToWatchlistFields = UnifiedFieldSelection<WatchlistItemResourceSchema>[];

export type InferAddToWatchlistResult<
  Fields extends AddToWatchlistFields | undefined,
> = InferResult<WatchlistItemResourceSchema, Fields>;

export type AddToWatchlistResult<Fields extends AddToWatchlistFields | undefined = undefined> = | { success: true; data: InferAddToWatchlistResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new WatchlistItem
 *
 * @ashActionType :create
 */
export async function addToWatchlist<Fields extends AddToWatchlistFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: AddToWatchlistInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<AddToWatchlistResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "add_to_watchlist",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<AddToWatchlistResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new WatchlistItem
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateAddToWatchlist(
  config: {
  tenant?: string;
  input: AddToWatchlistInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "add_to_watchlist",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}



export type RemoveFromWatchlistResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Delete a WatchlistItem
 *
 * @ashActionType :destroy
 */
export async function removeFromWatchlist(
  config: {
  tenant?: string;
  identity: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<RemoveFromWatchlistResult> {
  const payload = {
    action: "remove_from_watchlist",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeActionRpcRequest<RemoveFromWatchlistResult>(
    payload,
    config
  );
}


/**
 * Validate: Delete a WatchlistItem
 *
 * @ashActionType :destroy
 * @validation true
 */
export async function validateRemoveFromWatchlist(
  config: {
  tenant?: string;
  identity: UUID | string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "remove_from_watchlist",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ListUsersFields = UnifiedFieldSelection<UserResourceSchema>[];


export type InferListUsersResult<
  Fields extends ListUsersFields | undefined,
  Page extends ListUsersConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<UserResourceSchema, Fields>>, {
  results: Array<InferResult<UserResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<UserResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ListUsersConfig = {
  tenant?: string;
  fields: ListUsersFields;
  filter?: UserFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ListUsersResult<Fields extends ListUsersFields, Page extends ListUsersConfig["page"] = undefined> = | { success: true; data: InferListUsersResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Read User records
 *
 * @ashActionType :read
 */
export async function listUsers<Fields extends ListUsersFields, Config extends ListUsersConfig = ListUsersConfig>(
  config: Config & { fields: Fields }
): Promise<ListUsersResult<Fields, Config["page"]>> {
  const payload = {
    action: "list_users",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ListUsersResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


/**
 * Validate: Read User records
 *
 * @ashActionType :read
 * @validation true
 */
export async function validateListUsers(
  config: {
  tenant?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "list_users",
    ...(config.tenant !== undefined && { tenant: config.tenant })
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type UpdateProfileInput = {
  fullName?: string | null;
  phoneNumber?: string | null;
  location?: string | null;
};

export type UpdateProfileFields = UnifiedFieldSelection<UserResourceSchema>[];

export type InferUpdateProfileResult<
  Fields extends UpdateProfileFields | undefined,
> = InferResult<UserResourceSchema, Fields>;

export type UpdateProfileResult<Fields extends UpdateProfileFields | undefined = undefined> = | { success: true; data: InferUpdateProfileResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function updateProfile<Fields extends UpdateProfileFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input?: UpdateProfileInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateProfileResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_profile",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateProfileResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing User
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateUpdateProfile(
  config: {
  tenant?: string;
  identity: UUID | string;
  input?: UpdateProfileInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "update_profile",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type UpdateAutoChargeInput = {
  autoCharge?: boolean | null;
};

export type UpdateAutoChargeFields = UnifiedFieldSelection<UserResourceSchema>[];

export type InferUpdateAutoChargeResult<
  Fields extends UpdateAutoChargeFields | undefined,
> = InferResult<UserResourceSchema, Fields>;

export type UpdateAutoChargeResult<Fields extends UpdateAutoChargeFields | undefined = undefined> = | { success: true; data: InferUpdateAutoChargeResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function updateAutoCharge<Fields extends UpdateAutoChargeFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input?: UpdateAutoChargeInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateAutoChargeResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_auto_charge",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateAutoChargeResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing User
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateUpdateAutoCharge(
  config: {
  tenant?: string;
  identity: UUID | string;
  input?: UpdateAutoChargeInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "update_auto_charge",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type UpdateNotificationPreferencesInput = {
  notificationPreferences?: AngleAccountsNotificationPreferencesInputSchema | null;
};

export type UpdateNotificationPreferencesFields = UnifiedFieldSelection<UserResourceSchema>[];

export type InferUpdateNotificationPreferencesResult<
  Fields extends UpdateNotificationPreferencesFields | undefined,
> = InferResult<UserResourceSchema, Fields>;

export type UpdateNotificationPreferencesResult<Fields extends UpdateNotificationPreferencesFields | undefined = undefined> = | { success: true; data: InferUpdateNotificationPreferencesResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function updateNotificationPreferences<Fields extends UpdateNotificationPreferencesFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input?: UpdateNotificationPreferencesInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpdateNotificationPreferencesResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "update_notification_preferences",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpdateNotificationPreferencesResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing User
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateUpdateNotificationPreferences(
  config: {
  tenant?: string;
  identity: UUID | string;
  input?: UpdateNotificationPreferencesInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "update_notification_preferences",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type ChangePasswordInput = {
  currentPassword: string;
  password: string;
  passwordConfirmation: string;
};

export type ChangePasswordFields = UnifiedFieldSelection<UserResourceSchema>[];

export type InferChangePasswordResult<
  Fields extends ChangePasswordFields | undefined,
> = InferResult<UserResourceSchema, Fields>;

export type ChangePasswordResult<Fields extends ChangePasswordFields | undefined = undefined> = | { success: true; data: InferChangePasswordResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Update an existing User
 *
 * @ashActionType :update
 */
export async function changePassword<Fields extends ChangePasswordFields | undefined = undefined>(
  config: {
  tenant?: string;
  identity: UUID;
  input: ChangePasswordInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ChangePasswordResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "change_password",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ChangePasswordResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Update an existing User
 *
 * @ashActionType :update
 * @validation true
 */
export async function validateChangePassword(
  config: {
  tenant?: string;
  identity: UUID | string;
  input: ChangePasswordInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "change_password",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    identity: config.identity,
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


export type UpsertStoreProfileInput = {
  storeName: string;
  contactPhone?: string | null;
  whatsappLink?: string | null;
  location?: string | null;
  address?: string | null;
  deliveryPreference?: string | null;
  userId: UUID;
};

export type UpsertStoreProfileFields = UnifiedFieldSelection<StoreProfileResourceSchema>[];

export type InferUpsertStoreProfileResult<
  Fields extends UpsertStoreProfileFields | undefined,
> = InferResult<StoreProfileResourceSchema, Fields>;

export type UpsertStoreProfileResult<Fields extends UpsertStoreProfileFields | undefined = undefined> = | { success: true; data: InferUpsertStoreProfileResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

/**
 * Create a new StoreProfile
 *
 * @ashActionType :create
 */
export async function upsertStoreProfile<Fields extends UpsertStoreProfileFields | undefined = undefined>(
  config: {
  tenant?: string;
  input: UpsertStoreProfileInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<UpsertStoreProfileResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "upsert_store_profile",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<UpsertStoreProfileResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


/**
 * Validate: Create a new StoreProfile
 *
 * @ashActionType :create
 * @validation true
 */
export async function validateUpsertStoreProfile(
  config: {
  tenant?: string;
  input: UpsertStoreProfileInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ValidationResult> {
  const payload = {
    action: "upsert_store_profile",
    ...(config.tenant !== undefined && { tenant: config.tenant }),
    input: config.input
  };

  return executeValidationRpcRequest<ValidationResult>(
    payload,
    config
  );
}


